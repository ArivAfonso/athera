create extension if not exists "hypopg" with schema "extensions";

create table "public"."customization" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "author" uuid not null,
    "profile_layout" text default 'grid'::text
);


alter table "public"."customization" enable row level security;

create table "public"."interests" (
    "topic" uuid not null,
    "user_id" uuid not null
);


alter table "public"."interests" enable row level security;

alter table "public"."banned_users" add column "reason" text not null;

alter table "public"."drafts" add column "license" text;

alter table "public"."followers" alter column "follower" set not null;

alter table "public"."followers" alter column "following" set not null;

alter table "public"."notification_settings" alter column "user_id" set not null;

alter table "public"."posts" drop column "rawText";

alter table "public"."posts" add column "comments_allowed" boolean not null default true;

alter table "public"."posts" add column "featured" boolean not null default false;

alter table "public"."posts" add column "mod_score" double precision not null default '0'::double precision;

CREATE UNIQUE INDEX customization_author_key ON public.customization USING btree (author);

CREATE UNIQUE INDEX customization_pkey ON public.customization USING btree (id);

CREATE UNIQUE INDEX interests_pkey ON public.interests USING btree (topic, user_id);

CREATE UNIQUE INDEX notification_settings_user_id_key ON public.notification_settings USING btree (user_id);

alter table "public"."customization" add constraint "customization_pkey" PRIMARY KEY using index "customization_pkey";

alter table "public"."interests" add constraint "interests_pkey" PRIMARY KEY using index "interests_pkey";

alter table "public"."customization" add constraint "customization_author_fkey" FOREIGN KEY (author) REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."customization" validate constraint "customization_author_fkey";

alter table "public"."customization" add constraint "customization_author_key" UNIQUE using index "customization_author_key";

alter table "public"."interests" add constraint "interests_topic_fkey" FOREIGN KEY (topic) REFERENCES topics(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."interests" validate constraint "interests_topic_fkey";

alter table "public"."interests" add constraint "interests_user_fkey" FOREIGN KEY (user_id) REFERENCES users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."interests" validate constraint "interests_user_fkey";

alter table "public"."notification_settings" add constraint "notification_settings_user_id_key" UNIQUE using index "notification_settings_user_id_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.generate_username()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    first_word TEXT;
    random_number TEXT;
    generated_username TEXT;
BEGIN
    IF NEW.username IS NULL THEN
        -- Extract the first word of the user's name
        first_word := split_part(NEW.name, ' ', 1);
        
        -- Generate a random 3-digit number
        random_number := lpad((trunc(random() * 1000)::int)::text, 3, '0');
        
        -- Combine first word and random number to form the username
        generated_username := lower(first_word || random_number);
        
        -- Update the NEW row with the generated username
        NEW.username := generated_username;
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_banned_email()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Check if the new user's email is in the banned_users table
    IF EXISTS (SELECT 1 FROM public.banned_users WHERE email = NEW.email) THEN
        -- If the email is banned, delete the user
        DELETE FROM public.users WHERE id = NEW.id;
        DELETE FROM auth.users WHERE email = NEW.email;
    ELSE
        -- If the email is not banned, insert a new row into the notification_settings table
        INSERT INTO public.notification_settings (user_id) VALUES (NEW.id);
        -- If the email is not banned, insert a new row into the customization table
        INSERT INTO public.customization (author) VALUES (NEW.id);
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.check_scheduled_posts()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    UPDATE posts
    SET scheduled_at = NULL
    WHERE scheduled_at IS NOT NULL
    AND scheduled_at <= NOW();
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_author_data(author_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    author_record RECORD;
    author_data JSONB;
    follower_count INT;
    following_count INT;
    post_count INT;
    like_counts INT;
    comment_counts INT;
BEGIN
    -- Fetch follower count
    SELECT COUNT(DISTINCT f1.follower) INTO follower_count
    FROM followers f1
    WHERE f1.following = author_id;

    -- Fetch following count
    SELECT COUNT(DISTINCT f2.following) INTO following_count
    FROM followers f2
    WHERE f2.follower = author_id;

    -- Fetch post count
    SELECT COUNT(*) INTO post_count
    FROM posts
    WHERE author = author_id;

    -- Fetch like counts
    SELECT COUNT(*) INTO like_counts
    FROM likes
    WHERE post IN (SELECT id FROM posts WHERE author = author_id);

    -- Fetch comment counts
    SELECT COUNT(*) INTO comment_counts
    FROM comments
    WHERE post IN (SELECT id FROM posts WHERE author = author_id);

    -- Fetch author data
    SELECT
        u.id,
        u.name,
        follower_count AS followerCount,
        following_count AS followingCount,
        (
            SELECT JSONB_AGG(jsonb_build_object('following', f3.following))
            FROM followers f3
            WHERE f3.follower = author_id
        ) AS followers,
        EXISTS (
            SELECT 1
            FROM followers f4
            WHERE f4.follower = author_id AND f4.following = u.id
        ) AS isFollowing,
        u.username,
        u.background,
        u.bio,
        u.website,
        (
            SELECT JSONB_AGG(jsonb_build_object(
                'id', p.id,
                'title', p.title,
                'image', p.image,
                'created_at', p.created_at,
                'description', p.description,
                'author', jsonb_build_object(
                    'id', u.id,
                    'verified', u.verified,
                    'name', u.name,
                    'username', u.username,
                    'avatar', u.avatar
                ),
                'post_categories', (
                    SELECT JSONB_AGG(jsonb_build_object(
                        'category', jsonb_build_object(
                            'name', c.name,
                            'id', c.id,
                            'color', c.color
                        )
                    ))
                    FROM post_categories pc
                    JOIN categories c ON pc.category = c.id
                    WHERE pc.post = p.id
                ),
                'likeCount', jsonb_build_array(jsonb_build_object('count', like_counts)),
                'commentCount', jsonb_build_array(jsonb_build_object('count', comment_counts))
            ))
            FROM posts p
            WHERE p.author = author_id
        ) AS posts,
        u.avatar,
        u.twitter,
        u.facebook,
        u.instagram,
        u.linkedin,
        u.github,
        u.twitch,
        u.youtube,
        u.tiktok,
        u.pinterest,
        post_count AS postCount,
        u.verified
    INTO
        author_record
    FROM
        users u
    WHERE
        u.id = author_id;

    -- Convert record to JSONB
    author_data := jsonb_build_object(
        'id', author_record.id,
        'name', author_record.name,
        'followerCount', author_record.followerCount,
        'followingCount', author_record.followingCount,
        'followers', author_record.followers,
        'isFollowing', author_record.isFollowing,
        'username', author_record.username,
        'background', author_record.background,
        'bio', author_record.bio,
        'website', author_record.website,
        'posts', author_record.posts,
        'avatar', author_record.avatar,
        'twitter', author_record.twitter,
        'facebook', author_record.facebook,
        'instagram', author_record.instagram,
        'linkedin', author_record.linkedin,
        'github', author_record.github,
        'twitch', author_record.twitch,
        'youtube', author_record.youtube,
        'tiktok', author_record.tiktok,
        'pinterest', author_record.pinterest,
        'postCount', author_record.postCount,
        'verified', author_record.verified
    );

    -- Return author data
    RETURN author_data;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_author_data(author_username text)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    author_record RECORD;
    author_data JSONB;
    follower_count INT;
    following_count INT;
    post_count INT;
    like_counts INT;
    comment_counts INT;
BEGIN
    -- Fetch follower count
    SELECT COUNT(DISTINCT f1.follower) INTO follower_count
    FROM followers f1
    WHERE f1.following = (SELECT id FROM users WHERE username = author_username);

    -- Fetch following count
    SELECT COUNT(DISTINCT f2.following) INTO following_count
    FROM followers f2
    WHERE f2.follower = (SELECT id FROM users WHERE username = author_username);

    -- Fetch post count
    SELECT COUNT(*) INTO post_count
    FROM posts
    WHERE author = (SELECT id FROM users WHERE username = author_username);

    -- Fetch like counts
    SELECT COUNT(*) INTO like_counts
    FROM likes
    WHERE post IN (SELECT id FROM posts WHERE author = (SELECT id FROM users WHERE username = author_username));

    -- Fetch comment counts
    SELECT COUNT(*) INTO comment_counts
    FROM comments
    WHERE post IN (SELECT id FROM posts WHERE author = (SELECT id FROM users WHERE username = author_username));

    -- Fetch author data
    SELECT
        u.id,
        u.name,
        follower_count AS followerCount,
        following_count AS followingCount,
        (
            SELECT JSONB_AGG(jsonb_build_object('following', f3.following))
            FROM followers f3
            WHERE f3.follower = (SELECT id FROM users WHERE username = author_username)
        ) AS followers,
        EXISTS (
            SELECT 1
            FROM followers f4
            WHERE f4.follower = (SELECT id FROM users WHERE username = author_username) AND f4.following = u.id
        ) AS isFollowing,
        u.username,
        u.background,
        u.bio,
        u.website,
        (
            SELECT JSONB_AGG(jsonb_build_object(
                'id', p.id,
                'title', p.title,
                'image', p.image,
                'created_at', p.created_at,
                'description', p.description,
                'author', jsonb_build_object(
                    'id', u.id,
                    'verified', u.verified,
                    'name', u.name,
                    'username', u.username,
                    'avatar', u.avatar
                ),
                'post_categories', (
                    SELECT JSONB_AGG(jsonb_build_object(
                        'category', jsonb_build_object(
                            'name', c.name,
                            'id', c.id,
                            'color', c.color
                        )
                    ))
                    FROM post_categories pc
                    JOIN categories c ON pc.category = c.id
                    WHERE pc.post = p.id
                ),
                'likeCount', jsonb_build_array(jsonb_build_object('count', like_counts)),
                'commentCount', jsonb_build_array(jsonb_build_object('count', comment_counts))
            ))
            FROM posts p
            WHERE p.author = (SELECT id FROM users WHERE username = author_username)
        ) AS posts,
        u.avatar,
        u.twitter,
        u.facebook,
        u.instagram,
        u.linkedin,
        u.github,
        u.twitch,
        u.youtube,
        u.tiktok,
        u.pinterest,
        post_count AS postCount,
        u.verified
    INTO
        author_record
    FROM
        users u
    WHERE
        u.username = author_username;

    -- Convert record to JSONB
    author_data := jsonb_build_object(
        'id', author_record.id,
        'name', author_record.name,
        'followerCount', author_record.followerCount,
        'followingCount', author_record.followingCount,
        'followers', author_record.followers,
        'isFollowing', author_record.isFollowing,
        'username', author_record.username,
        'background', author_record.background,
        'bio', author_record.bio,
        'website', author_record.website,
        'posts', author_record.posts,
        'avatar', author_record.avatar,
        'twitter', author_record.twitter,
        'facebook', author_record.facebook,
        'instagram', author_record.instagram,
        'linkedin', author_record.linkedin,
        'github', author_record.github,
        'twitch', author_record.twitch,
        'youtube', author_record.youtube,
        'tiktok', author_record.tiktok,
        'pinterest', author_record.pinterest,
        'postCount', author_record.postCount,
        'verified', author_record.verified
    );

    -- Return author data
    RETURN author_data;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_category_data(category_id uuid)
 RETURNS TABLE(name text, id uuid, image text, postcount jsonb, post_categories jsonb, color text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        c.name,
        c.id,
        c.image,
        json_build_array(json_build_object('count', coalesce(pc.count, 0))) AS postCount,
        json_agg(json_build_object('post', json_build_object(
            'id', p.id,
            'title', p.title,
            'created_at', p.created_at,
            'description', p.description,
            'author', json_build_object(
                'id', u.id,
                'name', u.name,
                'username', u.username,
                'avatar', u.avatar,
                'description', u.bio
            ),
            'likeCount', json_build_array(json_build_object('count', coalesce(lc.count, 0))),
            'commentCount', json_build_array(json_build_object('count', coalesce(cc.count, 0))),
            'likes', l.likes,
            'bookmarks', b.bookmarks,
            'image', p.image,
            'post_categories', all_categories.categories
        ))) AS post_categories,
        c.color
    FROM
        categories c
    LEFT JOIN
        post_categories pc ON c.id = pc.category
    LEFT JOIN
        posts p ON pc.post = p.id
    LEFT JOIN
        users u ON p.author = u.id
    LEFT JOIN
        (
            SELECT post, COUNT(*) AS count
            FROM likes
            GROUP BY post
        ) lc ON p.id = lc.post
    LEFT JOIN
        (
            SELECT post, COUNT(*) AS count
            FROM comments
            GROUP BY post
        ) cc ON p.id = cc.post
    LEFT JOIN
        (
            SELECT post, json_agg(json_build_object('id', liker)) AS likes
            FROM likes
            GROUP BY post
        ) l ON p.id = l.post
    LEFT JOIN
        (
            SELECT post, json_agg(json_build_object('id', "user")) AS bookmarks
            FROM bookmarks
            GROUP BY post
        ) b ON p.id = b.post
    LEFT JOIN
        (
            SELECT pc2.post,
                   json_agg(json_build_object('category', json_build_object('name', categories.name, 'id', categories.id, 'color', categories.color))) AS categories
            FROM post_categories pc2
            JOIN categories ON pc2.category = categories.id
            GROUP BY pc2.post
        ) all_categories ON p.id = all_categories.post
    WHERE
        c.id = category_id
    GROUP BY
        c.id, p.id;

END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_home_data()
 RETURNS TABLE(id uuid, title text, image text, created_at timestamp with time zone, author jsonb, post_topics jsonb[], likecount jsonb[], commentcount jsonb[], bookmarkcount jsonb[])
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY 
    SELECT 
        p.id,
        p.title,
        p.image,
        p.created_at,
        jsonb_build_object(
            'id', u.id,
            'verified', u.verified,
            'name', u.name,
            'username', u.username,
            'avatar', u.avatar
        ) AS author,
        jsonb_agg(
            jsonb_build_object(
                'topic', jsonb_build_object(
                    'name', c.name,
                    'id', c.id,
                    'color', c.color
                )
            )
        ) AS post_topics,
        jsonb_build_array(jsonb_build_object('count', COALESCE(lc.count, 0))) AS likeCount,
        jsonb_build_array(jsonb_build_object('count', COALESCE(cc.count, 0))) AS commentCount,
        jsonb_build_array(jsonb_build_object('count', COALESCE(bc.count, 0))) AS bookmarkCount
    FROM 
        public.posts p
    JOIN 
        public.users u ON p.author = u.id
    LEFT JOIN LATERAL (
        SELECT COUNT(*) AS count
        FROM public.likes
        WHERE post = p.id
    ) lc ON true
    LEFT JOIN LATERAL (
        SELECT COUNT(*) AS count
        FROM public.comments
        WHERE post = p.id
    ) cc ON true
    LEFT JOIN LATERAL (
        SELECT COUNT(*) AS count
        FROM public.bookmarks
        WHERE post = p.id
    ) bc ON true
    LEFT JOIN public.post_topics pc ON p.id = pc.post
    LEFT JOIN public.topics c ON pc.topic = c.id
    GROUP BY p.id, u.id, u.verified, u.name, u.username, u.avatar
    ORDER BY COALESCE((SELECT COUNT(*) FROM public.likes WHERE post = p.id), 0) DESC
    LIMIT 10; -- Change the limit as needed to get top N most liked posts
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_home_data(current_user_uuid uuid)
 RETURNS TABLE(popular_posts posttype[], most_followed_users authortype[], most_post_categories categorytype[])
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Logic for getting popular posts
  popular_posts := (
    SELECT JSON_BUILD_OBJECT(
      'id', p.id,
      'title', p.title,
      'image', p.image,
      'created_at', p.created_at,
      'author', JSON_BUILD_OBJECT(
        'id', u.id::text,
        'verified', u.verified,
        'name', u.name,
        'username', u.username,
        'avatar', u.avatar,
        'description', u.bio
      ),
      'post_categories', (
        SELECT ARRAY_TO_JSON(ARRAY_AGG(JSON_BUILD_OBJECT('category', JSON_BUILD_OBJECT('name', c.name, 'color', c.color))))
        FROM categories c
        JOIN post_categories pc ON c.id = pc.category
        WHERE pc.post = p.id
      ),
      'likeCount', (
        SELECT JSON_BUILD_OBJECT('count', COUNT(*))
        FROM likes
        WHERE post = p.id
      ),
      'commentCount', (
        SELECT JSON_BUILD_OBJECT('count', COUNT(*))
        FROM comments
        WHERE post = p.id
      )
    ) FROM posts p
    JOIN users u ON p.author = u.id
    LIMIT 10
  );

  -- Logic for getting most followed users
  most_followed_users := (
    SELECT JSON_BUILD_OBJECT(
      'id', u.id::text,
      'name', u.name,
      'followerCount', (
        SELECT COUNT(*)
        FROM followers
        WHERE following = u.id
      ),
      'username', u.username,
      'bio', u.bio,
      'website', u.website,
      'avatar', u.avatar,
      'postCount', (
        SELECT COUNT(*)
        FROM posts
        WHERE author = u.id
      ),
      'verified', u.verified
    ) FROM users u
    JOIN followers f ON u.id = f.following
    GROUP BY u.id
    ORDER BY COUNT(f.id) DESC
    LIMIT 10
  );

  -- Logic for getting categories with the most posts
  most_post_categories := (
    SELECT JSON_BUILD_OBJECT(
      'name', c.name,
      'id', c.id,
      'postCount', (
        SELECT COUNT(*)
        FROM post_categories
        WHERE category = c.id
      ),
      'color', c.color
    ) FROM categories c
    JOIN post_categories pc ON c.id = pc.category
    GROUP BY c.id
    ORDER BY COUNT(pc.id) DESC
    LIMIT 10
  );

  RETURN;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_or_create_categories(input_categories character varying[])
 RETURNS SETOF topics
 LANGUAGE plpgsql
AS $function$
DECLARE
    cat_id uuid;
    cat_color character varying;
    cat_name character varying;
BEGIN
    FOREACH cat_name IN ARRAY categories LOOP
        SELECT id, color INTO cat_id, cat_color FROM categories WHERE name = cat_name;
        IF NOT FOUND THEN
            -- Generate random color
            cat_color := CASE floor(random()*4)::int
                             WHEN 0 THEN 'red'
                             WHEN 1 THEN 'green'
                             WHEN 2 THEN 'blue'
                             ELSE 'yellow'
                         END;
            -- Insert new category
            INSERT INTO categories (id, name, color) VALUES (gen_random_uuid(), cat_name, cat_color) RETURNING id INTO cat_id;
        END IF;
        RETURN NEXT cat_id;
    END LOOP;
    RETURN;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_post_data(post_id uuid)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
    post_record RECORD;
    post_json JSON;
BEGIN
    -- Fetch post data
    SELECT
        p.id,
        p.title,
        p.image,
        p.created_at,
        p."estimatedReadingTime",
        p.description,
        p.text,
        json_build_object('author_id', u.id, 'verified', u.verified, 'name', u.name, 'username', u.username, 'avatar', u.avatar, 'description', u.bio) AS author,
        (
            SELECT json_agg(
                json_build_object(
                    'category', json_build_object('name', c.name, 'id', c.id, 'color', c.color)
                )
            )
            FROM post_categories pc
            JOIN categories c ON pc.category = c.id
            WHERE pc.post = p.id
        ) AS post_categories,
        (
            SELECT COUNT(*)
            FROM likes
            WHERE post = p.id
        ) AS likeCount,
        (
            SELECT COUNT(*)
            FROM comments
            WHERE post = p.id
        ) AS commentCount,
        (
            SELECT json_agg(
                json_build_object('liker', json_build_object('id', liker))
            )
            FROM likes
            WHERE post = p.id
        ) AS likes,
        EXISTS (
            SELECT 1
            FROM likes
            WHERE post = p.id AND liker = 'current_user_id'
        ) AS isLiked,
        EXISTS (
            SELECT 1
            FROM bookmarks
            WHERE post = p.id AND "user" = 'current_user_id'
        ) AS isBookmarked,
        (
            SELECT COUNT(*)
            FROM bookmarks
            WHERE post = p.id
        ) AS bookmarkCount,
        (
            SELECT json_agg(
                json_build_object('user', json_build_object('id', "user"))
            )
            FROM bookmarks
            WHERE post = p.id
        ) AS bookmarks,
        (
            SELECT json_agg(
                json_build_object(
                    'commenter', json_build_object('name', uc.name, 'username', uc.username, 'image', uc.avatar, 'description', uc.bio), 
                    'comment', cm.comment, 
                    'created_at', cm.created_at
                )
            )
            FROM comments cm
            JOIN users uc ON cm.commenter = uc.id
            WHERE cm.post = p.id
        ) AS comments
    INTO
        post_record
    FROM
        posts p
    LEFT JOIN
        users u ON p.author = u.id
    WHERE
        p.id = post_id;

    -- Convert record to JSON
    SELECT json_build_object(
        'id', post_record.id,
        'title', post_record.title,
        'image', post_record.image,
        'created_at', post_record.created_at,
        'estimatedReadingTime', post_record."estimatedReadingTime",
        'description', post_record.description,
        'text', post_record.text,
        'author', post_record.author,
        'post_categories', post_record.post_categories,
        'likeCount', post_record.likeCount,
        'commentCount', post_record.commentCount,
        'likes', post_record.likes,
        'isLiked', post_record.isLiked,
        'isBookmarked', post_record.isBookmarked,
        'bookmarkCount', post_record.bookmarkCount,
        'bookmarks', post_record.bookmarks,
        'comments', post_record.comments
    ) INTO post_json;

    RETURN post_json;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_post_data(post_id uuid, current_user_id uuid)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
    post_record RECORD;
    post_json JSON;
BEGIN

    -- Fetch post data
    SELECT
        p.id,
        p.title,
        p.image,
        p.json,
        p.created_at,
        p."estimatedReadingTime",
        p.description,
        p.text,
        json_build_object('id', u.id, 'verified', u.verified, 'name', u.name, 'username', u.username, 'avatar', u.avatar, 'description', u.bio) AS author,
        (
            SELECT json_agg(
                json_build_object(
                    'category', json_build_object('name', c.name, 'id', c.id, 'color', c.color)
                )
            )
            FROM post_categories pc
            JOIN categories c ON pc.category = c.id
            WHERE pc.post = p.id
        ) AS post_categories,
        (
            SELECT COUNT(*)
            FROM likes
            WHERE post = p.id
        ) AS likeCount,
        (
            SELECT COUNT(*)
            FROM comments
            WHERE post = p.id
        ) AS commentCount,
        (
            SELECT json_agg(
                json_build_object('liker', json_build_object('id', liker))
            )
            FROM likes
            WHERE post = p.id
        ) AS likes,
        EXISTS (
            SELECT 1
            FROM likes
            WHERE post = p.id AND liker = current_user_id
        ) AS isLiked,
        EXISTS (
            SELECT 1
            FROM bookmarks
            WHERE post = p.id AND "user" = current_user_id
        ) AS isBookmarked,
        (
            SELECT COUNT(*)
            FROM bookmarks
            WHERE post = p.id
        ) AS bookmarkCount,
        (
            SELECT json_agg(
                json_build_object('user', json_build_object('id', "user"))
            )
            FROM bookmarks
            WHERE post = p.id
        ) AS bookmarks,
        (
            SELECT json_agg(
                json_build_object(
                    'commenter', json_build_object('name', uc.name, 'username', uc.username, 'image', uc.avatar, 'description', uc.bio), 
                    'comment', cm.comment, 
                    'created_at', cm.created_at
                )
            )
            FROM comments cm
            JOIN users uc ON cm.commenter = uc.id
            WHERE cm.post = p.id
        ) AS comments
    INTO
        post_record
    FROM
        posts p
    LEFT JOIN
        users u ON p.author = u.id
    WHERE
        p.id = post_id;

    -- Insert row into watch_history table
    INSERT INTO watch_history (post, user_id, created_at)
    VALUES (post_id, current_user_id, NOW());

    -- Convert record to JSON
    SELECT json_build_object(
        'id', post_record.id,
        'title', post_record.title,
        'image', post_record.image,
        'json', post_record.json,
        'created_at', post_record.created_at,
        'estimatedReadingTime', post_record."estimatedReadingTime",
        'description', post_record.description,
        'text', post_record.text,
        'author', post_record.author,
        'post_categories', post_record.post_categories,
        'likeCount', json_build_array(json_build_object('count', coalesce(post_record.likeCount, 0))),
        'commentCount', json_build_array(json_build_object('count', coalesce(post_record.commentCount, 0))),
        'likes', post_record.likes,
        'isLiked', post_record.isLiked,
        'isBookmarked', post_record.isBookmarked,
        'bookmarkCount', post_record.bookmarkCount,
        'bookmarks', post_record.bookmarks,
        'comments', post_record.comments
    ) INTO post_json;

    RETURN post_json;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_posts_in_category(category_id uuid)
 RETURNS TABLE(name text, id uuid, image text, postcount jsonb, post_categories jsonb, color text)
 LANGUAGE sql
 STABLE
AS $function$
    SELECT
        c.name,
        c.id,
        c.image,
        json_build_array(json_build_object('count', coalesce(pc.count, 0))) AS postCount,
        json_agg(json_build_object('post', json_build_object(
            'id', p.id,
            'title', p.title,
            'created_at', p.created_at,
            'description', p.description,
            'author', json_build_object(
                'id', u.id,
                'name', u.name,
                'username', u.username,
                'avatar', u.avatar,
                'description', u.bio
            ),
            'likeCount', json_build_array(json_build_object('count', coalesce(lc.count, 0))),
            'commentCount', json_build_array(json_build_object('count', coalesce(cc.count, 0))),
            'likes', l.likes,
            'bookmarks', b.bookmarks,
            'image', p.image,
            'categories', all_categories.categories
        ))) AS post_categories,
        c.color
    FROM
        categories c
    LEFT JOIN
        post_categories pc ON c.id = pc.category
    LEFT JOIN
        posts p ON pc.post = p.id
    LEFT JOIN
        users u ON p.author = u.id
    LEFT JOIN
        (
            SELECT post, COUNT(*) AS count
            FROM likes
            GROUP BY post
        ) lc ON p.id = lc.post
    LEFT JOIN
        (
            SELECT post, COUNT(*) AS count
            FROM comments
            GROUP BY post
        ) cc ON p.id = cc.post
    LEFT JOIN
        (
            SELECT post, json_agg(json_build_object('id', liker)) AS likes
            FROM likes
            GROUP BY post
        ) l ON p.id = l.post
    LEFT JOIN
        (
            SELECT post, json_agg(json_build_object('id', "user")) AS bookmarks
            FROM bookmarks
            GROUP BY post
        ) b ON p.id = b.post
    LEFT JOIN
        (
            SELECT pc2.post,
                   json_agg(json_build_object('name', categories.name, 'id', categories.id, 'color', categories.color)) AS categories
            FROM post_categories pc2
            JOIN categories ON pc2.category = categories.id
            GROUP BY pc2.post
        ) all_categories ON p.id = all_categories.post
    WHERE
        c.id = category_id
    GROUP BY
        c.id, p.id;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  insert into public.users (id, name, avatar, email)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url', new.raw_user_meta_data->>'email');
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.manage_categories(categories character varying[], OUT cat_id uuid, OUT cat_name character varying, OUT cat_color character varying)
 RETURNS SETOF record
 LANGUAGE plpgsql
AS $function$
BEGIN
    FOR cat_name IN SELECT unnest(categories) LOOP
        -- Check if category exists
        SELECT id, color INTO cat_id, cat_color FROM public.categories WHERE name = cat_name;
        
        -- If category doesn't exist, create it
        IF NOT FOUND THEN
            -- Generate random color
            cat_color := CASE floor(random()*4)::int
                             WHEN 0 THEN 'red'
                             WHEN 1 THEN 'green'
                             WHEN 2 THEN 'blue'
                             ELSE 'yellow'
                           END;
            -- Insert new category
            INSERT INTO public.categories (id, name, color) VALUES (gen_random_uuid(), cat_name, cat_color) RETURNING id INTO cat_id;
        END IF;
        
        -- Return category details
        RETURN NEXT;
    END LOOP;
    RETURN;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.manage_topics(topics character varying[], OUT top_id uuid, OUT top_name character varying, OUT top_color character varying)
 RETURNS SETOF record
 LANGUAGE plpgsql
AS $function$
BEGIN
    FOR top_name IN SELECT unnest(topics) LOOP
        -- Check if topic exists
        SELECT id, color INTO top_id, top_color FROM public.topics WHERE name = top_name;
        
        -- If topic doesn't exist, create it
        IF NOT FOUND THEN
            -- Generate random color
            top_color := CASE floor(random()*4)::int
                             WHEN 0 THEN 'red'
                             WHEN 1 THEN 'green'
                             WHEN 2 THEN 'blue'
                             ELSE 'yellow'
                           END;
            -- Insert new topic
            INSERT INTO public.topics (id, name, color) VALUES (gen_random_uuid(), top_name, top_color) RETURNING id INTO top_id;
        END IF;
        
        -- Return topic details
        RETURN NEXT;
    END LOOP;
    RETURN;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.match_posts(query_embedding vector, match_threshold double precision, match_count integer)
 RETURNS TABLE(id uuid, title text, created_at timestamp with time zone, description text, likecount jsonb, commentcount jsonb, likes jsonb, bookmarks jsonb, image text, author jsonb, post_categories jsonb, similarity double precision)
 LANGUAGE sql
 STABLE
AS $function$
  SELECT
    posts.id,
    posts.title,
    posts.created_at,
    posts.description,
    CASE
      WHEN COUNT(likes.post) = 0 THEN json_build_array(json_build_object('count', 0))
      ELSE json_build_array(json_build_object('count', COUNT(likes.post)))
    END AS likecount,
    CASE
      WHEN COUNT(comments.post) = 0 THEN json_build_array(json_build_object('count', 0))
      ELSE json_build_array(json_build_object('count', COUNT(comments.post)))
    END AS commentcount,
    json_agg(json_build_object('id', users.id)) AS likes,
    json_agg(json_build_object('id', users.id)) AS bookmarks,
    posts.image,
    json_build_object(
      'name', users.name,
      'username', users.username,
      'id', users.id,
      'verified', users.verified,
      'avatar', users.avatar
    ) AS author,
    json_agg(
      json_build_object(
        'category',
        json_build_object(
          'name', categories.name,
          'color', categories.color
        )
      )
    ) AS post_categories,
    1 - (posts.embeddings <=> query_embedding) AS similarity
  FROM posts
  LEFT JOIN users ON posts.author = users.id
  LEFT JOIN post_categories ON posts.id = post_categories.post
  LEFT JOIN categories ON post_categories.category = categories.id
  LEFT JOIN comments ON posts.id = comments.post
  LEFT JOIN likes ON posts.id = likes.post
  WHERE 1 - (posts.embeddings <=> query_embedding) > match_threshold
  GROUP BY posts.id, users.name, users.username, users.avatar, users.id, users.verified
  LIMIT match_count;
$function$
;

CREATE OR REPLACE FUNCTION public.match_posts(query_embedding vector, match_threshold double precision, match_count integer, filter_option text)
 RETURNS TABLE(id uuid, title text, created_at timestamp with time zone, description text, likecount jsonb, commentcount jsonb, likes jsonb, bookmarks jsonb, image text, author jsonb, post_topics jsonb, similarity double precision)
 LANGUAGE sql
 STABLE
AS $function$
  SELECT
    posts.id,
    posts.title,
    posts.created_at,
    posts.description,
    CASE
      WHEN COUNT(likes.post) = 0 THEN json_build_array(json_build_object('count', 0))
      ELSE json_build_array(json_build_object('count', COUNT(likes.post)))
    END AS likecount,
    CASE
      WHEN COUNT(comments.post) = 0 THEN json_build_array(json_build_object('count', 0))
      ELSE json_build_array(json_build_object('count', COUNT(comments.post)))
    END AS commentcount,
    json_agg(json_build_object('id', users.id)) AS likes,
    json_agg(json_build_object('id', users.id)) AS bookmarks,
    posts.image,
    json_build_object(
      'name', users.name,
      'username', users.username,
      'id', users.id,
      'verified', users.verified,
      'avatar', users.avatar
    ) AS author,
    json_agg(
      json_build_object(
        'topic',
        json_build_object(
          'name', topics.name,
          'color', topics.color
        )
      )
    ) AS post_topics,
    1 - (posts.embeddings <=> query_embedding) AS similarity
  FROM posts
  LEFT JOIN users ON posts.author = users.id
  LEFT JOIN post_topics ON posts.id = post_topics.post
  LEFT JOIN topics ON post_topics.topic = topics.id
  LEFT JOIN comments ON posts.id = comments.post
  LEFT JOIN likes ON posts.id = likes.post
  WHERE 1 - (posts.embeddings <=> query_embedding) > match_threshold AND posts.scheduled_at IS null
  GROUP BY posts.id, users.name, users.username, users.avatar, users.id, users.verified
  ORDER BY
    CASE
      WHEN filter_option = 'most_relevant' THEN 1 - (posts.embeddings <=> query_embedding)
      WHEN filter_option = 'most_commented' THEN COUNT(comments.post)
      WHEN filter_option = 'most_recent' THEN extract(epoch from posts.created_at)
      WHEN filter_option = 'most_liked' THEN COUNT(likes.post)
      ELSE 1 - (posts.embeddings <=> query_embedding)
    END DESC
  LIMIT match_count;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_on_comment()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    -- Check if notifications column is set to true for the user_id in the users table
    if (select notifications from users where id = (select author from posts where id = new.post)) then
        -- Insert a new row into the notifications table when a comment is added
        insert into notifications (id, created_at, avatar, type, user_id, notifier, post)
        select gen_random_uuid(), now(), u.avatar, 'comment', p.author, new.commenter, p.id
        from users u
        join posts p on p.id = new.post
        where u.id = new.commenter;
    end if;
    return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_on_follow()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    -- Check if notifications column is set to true for the user_id in the users table
    if (select notifications from users where id = new.following) then
        -- Insert a new row into the notifications table when a user is followed
        insert into notifications (id, created_at, avatar, type, user_id, notifier)
        select gen_random_uuid(), now(), u.avatar, 'follow', new.following, new.follower
        from users u
        where u.id = new.follower;
    end if;
    return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_on_like()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    -- Check if notifications column is set to true for the user_id in the users table
    if (select notifications from users u
        join posts p on p.id = new.post_id
        where u.id = p.author) then
        -- Insert a new row into the notifications table when a post is liked
        insert into notifications (id, created_at, avatar, type, user_id, notifier_id)
        select gen_random_uuid(), now(), new.liker_avatar, 'like', p.author, new.liker_id
        from posts p
        where p.id = new.post_id;
    end if;
    return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.related_posts(post_id uuid, match_threshold double precision, match_count integer)
 RETURNS TABLE(id uuid, title text, created_at timestamp with time zone, description text, likecount jsonb, commentcount jsonb, likes jsonb, bookmarks jsonb, image text, author jsonb, post_topics jsonb, similarity double precision)
 LANGUAGE sql
 STABLE
AS $function$
  SELECT
    posts.id,
    posts.title,
    posts.created_at,
    posts.description,
    json_build_array(
      json_build_object('count', coalesce(count(*) OVER (PARTITION BY posts.id), 0))
    ) AS likecount,
    json_build_array(
      json_build_object('count', coalesce(count(*) OVER (PARTITION BY posts.id), 0))
    ) AS commentcount,
    json_agg(json_build_object('id', users.id)) AS likes,
    json_agg(json_build_object('id', users.id)) AS bookmarks,
    posts.image,
    json_build_object('name', users.name, 'username', users.username, 'avatar', users.avatar) AS author,
    (
      SELECT json_agg(
        json_build_object(
          'topic',
          json_build_object(
            'name',
            topics.name,
            'color',
            topics.color
          )
        )
      )
      FROM post_topics pc2
      LEFT JOIN topics ON pc2.topic = topics.id
      WHERE pc2.post = posts.id
    ) AS post_topics,
    1 - (posts.embeddings <=> posts.embeddings) AS similarity
  FROM posts
  LEFT JOIN users ON posts.author = users.id
  LEFT JOIN post_topics ON posts.id = post_topics.post
  LEFT JOIN topics ON post_topics.topic = topics.id
  LEFT JOIN comments ON posts.id = comments.post
  LEFT JOIN post_topics pc ON pc.post = posts.id
  LEFT JOIN posts related_posts ON related_posts.id = pc.post
  WHERE related_posts.id = post_id
    AND posts.id <> post_id -- Exclude the post with the same ID
    AND 1 - (posts.embeddings <=> posts.embeddings) > match_threshold
    AND posts.scheduled_at IS NULL
  GROUP BY posts.id, users.name, users.username, users.avatar
  LIMIT match_count;
$function$
;

CREATE OR REPLACE FUNCTION public.remove_comment_notification()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    -- Delete the corresponding row in the notifications table when a comment is deleted
    delete from notifications
    where user_id = (select author from posts where id = old.post) and notifier = old.commenter;
    return old;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.remove_follow_notification()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    -- Delete the corresponding row in the notifications table when a user is unfollowed
    delete from notifications
    where user_id = old.following and notifier = old.follower;
    return old;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.remove_like_notification()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    -- Delete the corresponding row in the notifications table when a post is unliked
    delete from notifications
    where user_id = (select author from posts where id = old.post_id) and notifier_id = old.liker_id;
    return old;
end;
$function$
;

grant delete on table "public"."customization" to "anon";

grant insert on table "public"."customization" to "anon";

grant references on table "public"."customization" to "anon";

grant select on table "public"."customization" to "anon";

grant trigger on table "public"."customization" to "anon";

grant truncate on table "public"."customization" to "anon";

grant update on table "public"."customization" to "anon";

grant delete on table "public"."customization" to "authenticated";

grant insert on table "public"."customization" to "authenticated";

grant references on table "public"."customization" to "authenticated";

grant select on table "public"."customization" to "authenticated";

grant trigger on table "public"."customization" to "authenticated";

grant truncate on table "public"."customization" to "authenticated";

grant update on table "public"."customization" to "authenticated";

grant delete on table "public"."customization" to "service_role";

grant insert on table "public"."customization" to "service_role";

grant references on table "public"."customization" to "service_role";

grant select on table "public"."customization" to "service_role";

grant trigger on table "public"."customization" to "service_role";

grant truncate on table "public"."customization" to "service_role";

grant update on table "public"."customization" to "service_role";

grant delete on table "public"."interests" to "anon";

grant insert on table "public"."interests" to "anon";

grant references on table "public"."interests" to "anon";

grant select on table "public"."interests" to "anon";

grant trigger on table "public"."interests" to "anon";

grant truncate on table "public"."interests" to "anon";

grant update on table "public"."interests" to "anon";

grant delete on table "public"."interests" to "authenticated";

grant insert on table "public"."interests" to "authenticated";

grant references on table "public"."interests" to "authenticated";

grant select on table "public"."interests" to "authenticated";

grant trigger on table "public"."interests" to "authenticated";

grant truncate on table "public"."interests" to "authenticated";

grant update on table "public"."interests" to "authenticated";

grant delete on table "public"."interests" to "service_role";

grant insert on table "public"."interests" to "service_role";

grant references on table "public"."interests" to "service_role";

grant select on table "public"."interests" to "service_role";

grant trigger on table "public"."interests" to "service_role";

grant truncate on table "public"."interests" to "service_role";

grant update on table "public"."interests" to "service_role";

create policy "Enable insert for authenticated users only"
on "public"."customization"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."customization"
as permissive
for select
to public
using (true);


create policy "Enable update for users based on author"
on "public"."customization"
as permissive
for update
to public
using ((( SELECT auth.uid() AS uid) = author));


create policy "Enable delete for users based on user_id"
on "public"."interests"
as permissive
for delete
to public
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Enable insert for authenticated users only"
on "public"."interests"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for select roles and user_id"
on "public"."interests"
as permissive
for select
to dashboard_user, postgres, service_role, supabase_admin
using ((( SELECT auth.uid() AS uid) = user_id));


CREATE TRIGGER trigger_generate_username BEFORE INSERT ON public.users FOR EACH ROW EXECUTE FUNCTION generate_username();


